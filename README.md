# Design-Patterns
**设计模式**

:mag:行为型模式
+ :bulb:[策略模式](#0)
+ [模板方法模式](#3) 
+ [观察者模式](#1) 
+ [迭代子模式](#)
+ [责任链模式](#)
+ [命令模式](#)
+ [备忘录模式](#)
+ [访问者模式](#)
+ [中介者模式](#)
+ [解释器模式](#)

:mag: 创建型模式
+ [单例模式](#2) 
+ [工厂方法模式](#)
+ [抽象工厂模式](#)
+ [建造者模式](#)
+ [原型模式](#)

:mag:结构型模式
+ [适配器模式](#4) 
+ [装饰器模式](#)
+ [代理模式](#)
+ [外观模式](#)
+ [桥接模式](#)
+ [组合模式](#)
+ [享元模式](#)
---
OO基础：
> 抽象、封装、多态、继承

OO原则：
>封装变化  
>多用组合，少用接口  
>针对接口编程

---
<a name="0"></a>
+ 策略模式：
>定义了<font color="red">算法簇</font>,并分别进行封装，让他们相互之间可以替换，该模式让算法的变化独立于使用算法的客户  
>*算法簇：可以简单理解为：本例中即为鸭子的行为，即鸭子可以做的事情*

**`注意：`** 
1. 代码中鸭子的行为不是继承来的，而是通过行为对象的"组合"而来的  
2. 运行时动态改变行为，依赖Duck类中的Set行为对象方法来实现
3. 把最公有的相同的方法放在父类中，将可以变化的方法抽取成接口，并通过组合的方式放到父类中，子类通过插入不同的接口实现，完成类的配置

<a name="1"></a>
+ 观察者模式：
>定义了对象之间的一对多依赖，当一个对象状态改变时，它的所有的依赖者都会收到通知并自动更新
>自定义实现了观察者模式  
>使用java内置包实现了观察者模式

*todo:留待补充*

<a name="2"></a>
+ 单例模式：
>确保一个类只有一个实例，并提供一个全局访问点

``` java
三大要素：
	1.私有的构造方法
	2.指向实例的静态引用
	3.获取实例的公开静态get方法
```
> 实现了饿汉式和懒汉式，并对懒汉式在多线程情景下，进行了补充：
>synchronied函数式 --> synchronied代码块式 --> 内部类延迟加载懒汉式 --> 双重检查同步延时加载式 --> ThreadLocal变体式

*todo:留待补充*

<a name="3"></a>
+ 模板方法模式：
>模板方法模式是类的行为模式。准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。  
>不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现,是**基于继承的代码复用**的基本技术  

``` java
抽象模板:
1.定义了一个或多个抽象操作，以便让子类实现
2.定义并实现了一个模板方法。它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现
具体模板：
1.实现父类所定义的一个或多个抽象方法
2.每一个抽象模板角色都可以有任意多个具体模板角色与之对应，每一个具体模板都可以给出这些抽象方法的不同实现

```
关键思想：**子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑**  
详情见代码<做饭的例子>


<a name="4"></a>
+ 适配器模式：





